// GraphElement.h
#pragma once
#include <map>
#include <string>

using namespace System;
using namespace System::Drawing;
using namespace System::Collections::Generic;

namespace MaltegoClone {
    public enum class ElementType {
        Person, Organization, Website, IPAddress, Email,
        Document, SocialNetwork, School, Address, PhoneNumber, Custom
    };

    public ref class GraphElement {
    public:
        int id;
        ElementType type;
        String^ text;
        Point location;
        Size size;
        Color color;
        Dictionary<String^, String^>^ properties;
        bool is_expanded;
        String^ notes;

        GraphElement() {
            properties = gcnew Dictionary<String^, String^>();
            is_expanded = false;
            notes = String::Empty;
            color = Color::FromArgb(45, 45, 48);
            size = Size(120, 40);
        }

        property Rectangle bounds {
            Rectangle get() { return Rectangle(location, size); }
        }

        virtual void Draw(Graphics^ g) = 0;
        virtual void Expand() { is_expanded = !is_expanded; UpdateSize(); }
        virtual void UpdateSize() {
            size = is_expanded ? Size(250, 150) : Size(120, 40);
        }
    };
}

// GraphNode.h
#pragma once
#include "GraphElement.h"

using namespace System;
using namespace System::Drawing;
using namespace System::Windows::Forms;

namespace MaltegoClone {
    public ref class GraphNode : public GraphElement {
    public:
        event EventHandler^ NodeChanged;
        event EventHandler^ NodeDeleted;

        GraphNode() {
            this->Editable = true;
            this->ShowDeleteButton = false;
            this->ShowEditButton = false;
            this->Hovered = false;
        }

        virtual void Draw(Graphics^ g) override {
            // Draw main rectangle with hover effect
            SolidBrush^ brush = gcnew SolidBrush(Hovered ? 
                Color::FromArgb(Math::Min(color.R + 30, 255),
                Math::Min(color.G + 30, 255),
                Math::Min(color.B + 30, 255)) : color);
            
            Pen^ pen = gcnew Pen(Color::FromArgb(100, 100, 100), 1.5f);
            g->FillRectangle(brush, bounds);
            g->DrawRectangle(pen, bounds);

            // Draw buttons when hovered
            if (Hovered && ShowDeleteButton)
                DrawButton(g, bounds.Right - 20, bounds.Top, "X", Color::Red);
            
            if (Hovered && ShowEditButton)
                DrawButton(g, bounds.Right - 40, bounds.Top, "E", Color::Blue);

            // Draw title
            System::Drawing::Font^ font = gcnew System::Drawing::Font("Arial", 9, FontStyle::Bold);
            StringFormat^ format = gcnew StringFormat();
            format->Alignment = StringAlignment::Center;
            format->LineAlignment = StringAlignment::Center;
            g->DrawString(text, font, Brushes::White,
                RectangleF(location.X, location.Y, size.Width, 30), format);

            // Draw properties if expanded
            if (is_expanded) {
                System::Drawing::Font^ propFont = gcnew System::Drawing::Font("Arial", 8);
                int y_offset = location.Y + 35;
                
                for each (KeyValuePair<String^, String^> pair in properties) {
                    RectangleF propRect(location.X + 5, y_offset, size.Width - 10, 15);
                    
                    // Draw property background
                    g->FillRectangle(Brushes::LightGray, propRect);
                    
                    // Draw property text
                    String^ propText = pair.Key + ": " + pair.Value;
                    g->DrawString(propText, propFont, Brushes::Black, propRect);
                    
                    y_offset += 15;
                }
            }
        }

        void BeginEditTitle(Control^ parent) {
            if (!Editable) return;

            TextBox^ editBox = gcnew TextBox();
            editBox->Text = this->text;
            editBox->Bounds = Rectangle(location.X, location.Y, size.Width, 30);
            editBox->Font = gcnew System::Drawing::Font("Arial", 9, FontStyle::Bold);
            editBox->TextAlign = HorizontalAlignment::Center;
            editBox->Tag = this;
            
            editBox->KeyDown += gcnew KeyEventHandler(this, &GraphNode::EditBox_KeyDown);
            editBox->LostFocus += gcnew EventHandler(this, &GraphNode::EditBox_LostFocus);
            
            parent->Controls->Add(editBox);
            editBox->Focus();
        }

        property bool Editable;
        property bool ShowDeleteButton;
        property bool ShowEditButton;
        property bool Hovered;

    private:
        void DrawButton(Graphics^ g, int x, int y, String^ text, Color color) {
            Rectangle buttonRect(x, y, 20, 20);
            SolidBrush^ brush = gcnew SolidBrush(color);
            g->FillRectangle(brush, buttonRect);
            g->DrawString(text, gcnew System::Drawing::Font("Arial", 8, FontStyle::Bold), 
                Brushes::White, PointF(x + 5, y + 3));
        }

        void EditBox_KeyDown(Object^ sender, KeyEventArgs^ e) {
            if (e->KeyCode == Keys::Enter)
                CompleteEditing((TextBox^)sender);
        }

        void EditBox_LostFocus(Object^ sender, EventArgs^ e) {
            CompleteEditing((TextBox^)sender);
        }

        void CompleteEditing(TextBox^ editBox) {
            this->text = editBox->Text;
            editBox->Parent->Controls->Remove(editBox);
            NodeChanged(this, EventArgs::Empty);
        }
    };
}

// GraphEdge.h
#pragma once
#include "GraphElement.h"

namespace MaltegoClone {
    public ref class GraphEdge {
    public:
        GraphElement^ source;
        GraphElement^ target;
        PointF start_point;
        PointF end_point;
        Color color;
        float width;

        GraphEdge() {
            color = Color::FromArgb(100, 100, 100);
            width = 1.5f;
        }

        void UpdateConnectionPoints() {
            if (source != nullptr && target != nullptr) {
                start_point = GetConnectionPoint(source, target->location);
                end_point = GetConnectionPoint(target, source->location);
            }
        }

        void Draw(Graphics^ g) {
            UpdateConnectionPoints();
            
            // Draw line
            Pen^ pen = gcnew Pen(color, width);
            g->DrawLine(pen, start_point, end_point);

            // Draw arrow head
            DrawArrowHead(g);
        }

    private:
        PointF GetConnectionPoint(GraphElement^ element, PointF reference_point) {
            Rectangle bounds = element->bounds;
            PointF center = PointF(bounds.X + bounds.Width / 2, bounds.Y + bounds.Height / 2);

            float dx = reference_point.X - center.X;
            float dy = reference_point.Y - center.Y;
            float distance = (float)Math::Sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                dx /= distance;
                dy /= distance;
            }

            return PointF(
                center.X + dx * bounds.Width / 2,
                center.Y + dy * bounds.Height / 2);
        }

        void DrawArrowHead(Graphics^ g) {
            float arrow_length = 10.0f;
            float arrow_width = 4.0f;

            float dx = end_point.X - start_point.X;
            float dy = end_point.Y - start_point.Y;
            float length = (float)Math::Sqrt(dx * dx + dy * dy);

            if (length > 0) {
                dx /= length;
                dy /= length;
            }

            PointF adjusted_end = PointF(
                end_point.X - dx * arrow_length * 0.7f,
                end_point.Y - dy * arrow_length * 0.7f);

            PointF arrow_left = PointF(
                adjusted_end.X - dy * arrow_width,
                adjusted_end.Y + dx * arrow_width);
            
            PointF arrow_right = PointF(
                adjusted_end.X + dy * arrow_width,
                adjusted_end.Y - dx * arrow_width);

            array<PointF>^ arrow_points = gcnew array<PointF> { end_point, arrow_left, arrow_right };
            SolidBrush^ brush = gcnew SolidBrush(color);
            g->FillPolygon(brush, arrow_points);
        }
    };
}

// NodePropertiesEditor.h
#pragma once
#include "GraphElement.h"

using namespace System;
using namespace System::Windows::Forms;
using namespace System::Drawing;

namespace MaltegoClone {
    public ref class NodePropertiesEditor : public Form {
    public:
        NodePropertiesEditor(GraphElement^ element) {
            element_ref = element;
            InitializeComponent();
            InitializeProperties();
        }

    private:
        GraphElement^ element_ref;
        PropertyGrid^ property_grid;
        TextBox^ notes_box;
        Button^ save_button;

        void InitializeComponent() {
            this->Text = "Edit Node Properties";
            this->Size = System::Drawing::Size(450, 600);
            this->FormBorderStyle = FormBorderStyle::FixedDialog;
            this->StartPosition = FormStartPosition::CenterParent;

            // Property Grid
            property_grid = gcnew PropertyGrid();
            property_grid->Dock = DockStyle::Top;
            property_grid->Height = 400;
            this->Controls->Add(property_grid);

            // Notes
            Label^ notes_label = gcnew Label();
            notes_label->Text = "Notes:";
            notes_label->Location = Point(10, 410);
            this->Controls->Add(notes_label);

            notes_box = gcnew TextBox();
            notes_box->Multiline = true;
            notes_box->Location = Point(10, 430);
            notes_box->Size = System::Drawing::Size(410, 100);
            notes_box->Text = element_ref->notes;
            this->Controls->Add(notes_box);

            // Save Button
            save_button = gcnew Button();
            save_button->Text = "Save Changes";
            save_button->Location = Point(150, 540);
            save_button->Size = System::Drawing::Size(150, 30);
            save_button->Click += gcnew EventHandler(this, &NodePropertiesEditor::SaveChanges);
            this->Controls->Add(save_button);
        }

        void InitializeProperties() {
            property_grid->SelectedObject = element_ref;
        }

        void SaveChanges(Object^ sender, EventArgs^ e) {
            element_ref->notes = notes_box->Text;
            this->DialogResult = Windows::Forms::DialogResult::OK;
            this->Close();
        }
    };
}

// MainForm.h (основной код с улучшениями)
#pragma once
#include "GraphElement.h"
#include "GraphNode.h"
#include "GraphEdge.h"
#include "NodePropertiesEditor.h"

using namespace System;
using namespace System::Drawing;
using namespace System::Windows::Forms;
using namespace System::Collections::Generic;

namespace MaltegoClone {
    public ref class MainForm : public Form {
    public:
        MainForm() {
            InitializeComponent();
            InitializeToolbox();
            InitializeDarkTheme();
            InitializeContextMenu();
            InitializeFullScreen();

            graph_elements = gcnew List<GraphElement^>();
            edges = gcnew List<GraphEdge^>();
            node_id_counter = 1;
        }

    private:
        // UI Controls
        Panel^ graph_panel;
        ListBox^ toolbox;
        Button^ toggleFullScreenBtn;
        ContextMenuStrip^ node_context_menu;
        
        // Graph data
        List<GraphElement^>^ graph_elements;
        List<GraphEdge^>^ edges;
        int node_id_counter;
        
        // Full screen
        bool isFullScreen = false;
        FormWindowState previousWindowState;
        Size previousSize;
        Point previousLocation;

        void InitializeComponent() {
            // Main form setup
            this->Text = "Advanced Maltego Clone";
            this->Size = System::Drawing::Size(1200, 800);
            this->StartPosition = FormStartPosition::CenterScreen;
            this->KeyPreview = true;
            this->KeyDown += gcnew KeyEventHandler(this, &MainForm::MainForm_KeyDown);

            // Toolbox
            toolbox = gcnew ListBox();
            toolbox->SelectionMode = SelectionMode::One;
            toolbox->Size = System::Drawing::Size(200, 400);
            toolbox->Location = Point(10, 50);
            toolbox->MouseDown += gcnew MouseEventHandler(this, &MainForm::ToolboxMouseDown);
            this->Controls->Add(toolbox);

            // Graph panel
            graph_panel = gcnew Panel();
            graph_panel->Location = Point(220, 50);
            graph_panel->Size = System::Drawing::Size(950, 700);
            graph_panel->BackColor = Color::White;
            graph_panel->BorderStyle = BorderStyle::FixedSingle;
            graph_panel->MouseDown += gcnew MouseEventHandler(this, &MainForm::GraphPanelMouseDown);
            graph_panel->MouseMove += gcnew MouseEventHandler(this, &MainForm::GraphPanelMouseMove);
            graph_panel->MouseUp += gcnew MouseEventHandler(this, &MainForm::GraphPanelMouseUp);
            graph_panel->Paint += gcnew PaintEventHandler(this, &MainForm::GraphPanelPaint);
            graph_panel->DoubleClick += gcnew EventHandler(this, &MainForm::GraphPanelDoubleClick);
            this->Controls->Add(graph_panel);

            // Full screen button
            toggleFullScreenBtn = gcnew Button();
            toggleFullScreenBtn->Text = "Full Screen (F11)";
            toggleFullScreenBtn->Location = Point(10, 10);
            toggleFullScreenBtn->Click += gcnew EventHandler(this, &MainForm::ToggleFullScreen);
            this->Controls->Add(toggleFullScreenBtn);
        }

        void InitializeFullScreen() {
            this->WindowState = FormWindowState::Maximized;
            this->FormBorderStyle = FormBorderStyle::Sizable;
        }

        void ToggleFullScreen(Object^ sender, EventArgs^ e) {
            if (isFullScreen) {
                // Exit full screen
                this->FormBorderStyle = FormBorderStyle::Sizable;
                this->WindowState = previousWindowState;
                this->Size = previousSize;
                this->Location = previousLocation;
            } else {
                // Enter full screen
                previousWindowState = this->WindowState;
                previousSize = this->Size;
                previousLocation = this->Location;
                
                this->FormBorderStyle = FormBorderStyle::None;
                this->WindowState = FormWindowState::Maximized;
            }
            isFullScreen = !isFullScreen;
            AdjustLayoutForFullScreen();
        }

        void AdjustLayoutForFullScreen() {
            if (isFullScreen) {
                graph_panel->Dock = DockStyle::Fill;
                toolbox->Visible = false;
                toggleFullScreenBtn->Text = "Exit Full Screen (F11)";
            } else {
                graph_panel->Dock = DockStyle::None;
                graph_panel->Location = Point(220, 50);
                graph_panel->Size = System::Drawing::Size(950, 700);
                toolbox->Visible = true;
                toggleFullScreenBtn->Text = "Full Screen (F11)";
            }
        }

        void MainForm_KeyDown(Object^ sender, KeyEventArgs^ e) {
            if (e->KeyCode == Keys::F11) {
                ToggleFullScreen(sender, e);
            }
        }

        // ... остальные методы (инициализация, обработчики событий и т.д.) ...
    };
}

// PropertyEditor.h (для редактирования свойств)
#pragma once

using namespace System;
using namespace System::Windows::Forms;

namespace MaltegoClone {
    public ref class PropertyEditor : public Form {
    public:
        property String^ PropertyName { String^ get() { return nameBox->Text; } }
        property String^ PropertyValue { String^ get() { return valueBox->Text; } }

        PropertyEditor() {
            InitializeComponent();
        }

    private:
        TextBox^ nameBox;
        TextBox^ valueBox;

        void InitializeComponent() {
            this->Text = "Edit Property";
            this->Size = System::Drawing::Size(300, 150);
            this->FormBorderStyle = FormBorderStyle::FixedDialog;
            this->StartPosition = FormStartPosition::CenterParent;

            // Name label and textbox
            Label^ nameLabel = gcnew Label();
            nameLabel->Text = "Name:";
            nameLabel->Location = Point(10, 10);
            this->Controls->Add(nameLabel);

            nameBox = gcnew TextBox();
            nameBox->Location = Point(80, 10);
            nameBox->Size = System::Drawing::Size(200, 20);
            this->Controls->Add(nameBox);

            // Value label and textbox
            Label^ valueLabel = gcnew Label();
            valueLabel->Text = "Value:";
            valueLabel->Location = Point(10, 40);
            this->Controls->Add(valueLabel);

            valueBox = gcnew TextBox();
            valueBox->Location = Point(80, 40);
            valueBox->Size = System::Drawing::Size(200, 20);
            this->Controls->Add(valueBox);

            // OK and Cancel buttons
            Button^ okButton = gcnew Button();
            okButton->Text = "OK";
            okButton->Location = Point(50, 80);
            okButton->DialogResult = Windows::Forms::DialogResult::OK;
            this->Controls->Add(okButton);

            Button^ cancelButton = gcnew Button();
            cancelButton->Text = "Cancel";
            cancelButton->Location = Point(150, 80);
            cancelButton->DialogResult = Windows::Forms::DialogResult::Cancel;
            this->Controls->Add(cancelButton);

            this->AcceptButton = okButton;
            this->CancelButton = cancelButton;
        }
    };
}

// WinMain (точка входа)
[STAThread]
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    Application::EnableVisualStyles();
    Application::SetCompatibleTextRenderingDefault(false);
    Application::Run(gcnew MaltegoClone::MainForm());
    return 0;
}